<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Joins · JuliaDB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/custom.js"></script></head><body><nav class="toc"><h1>JuliaDB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="index.html">API Reference</a></li><li><a class="toctext" href="datastructures.html">Data Structures</a></li><li><a class="toctext" href="selection.html">Selection</a></li><li><a class="toctext" href="aggregation.html">Aggregation</a></li><li class="current"><a class="toctext" href="joins.html">Joins</a><ul class="internal"><li><a class="toctext" href="#Merge-1">Merge</a></li><li><a class="toctext" href="#Broadcast-1">Broadcast</a></li></ul></li><li><a class="toctext" href="io.html">Loading and Saving</a></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li><a class="toctext" href="../manual/onlinestats.html">OnlineStats Integration</a></li><li><a class="toctext" href="../manual/out-of-core.html">Out-of-core functionality</a></li><li><a class="toctext" href="../manual/ml.html">Feature Extraction</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="joins.html">Joins</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/master/docs/src/api/joins.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Joins</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Joins-1" href="#Joins-1">Joins</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>join([f, ] left, right; how, &lt;options&gt;)</code></p><p>Join two tables (<code>left</code> and <code>right</code>). <code>how</code> specifies which join method is used (one of <code>:inner</code>, <code>:left</code>, <code>:right</code>, <code>:outer</code> and <code>:anti</code>). By default, join keys are implied to be the primary keys, but this can be changed using the <code>lkey</code> and <code>rkey</code> options. See Options section below.</p><p>The function <code>f</code> must take 2 arguments: tuples of non-key fields from both tables as input. The fields chosen for <code>f</code> can be configured using <code>lselect</code> and <code>rselect</code> options. See Options section below. If <code>f</code> is not specified, then these tuples are concatenated to form the non-indexed fields of the output.</p><p><strong>Inner join</strong></p><p>Inner join is the default join (when <code>how</code> is unspecified). It looks up keys from <code>left</code> in <code>right</code> and only joins them when there is a match. This generates the &quot;intersection&quot; of keys from <code>left</code> and <code>right</code>.</p><pre><code class="language-julia-repl">julia&gt; l = table([1,1,2,2], [1,2,1,2], [1,2,3,4],
                 names=[:a,:b,:c], pkey=(:a, :b))
Table with 4 rows, 3 columns:
a  b  c
───────
1  1  1
1  2  2
2  1  3
2  2  4

julia&gt; r = table([0,1,1,3], [1,1,2,2], [1,2,3,4],
                 names=[:a,:b,:d], pkey=(:a, :b))
Table with 4 rows, 3 columns:
a  b  d
───────
0  1  1
1  1  2
1  2  3
3  2  4

julia&gt; join(l,r) # inner join
Table with 2 rows, 4 columns:
a  b  c  d
──────────
1  1  1  2
1  2  2  3</code></pre><p><strong>Left join</strong></p><p>Left join looks up rows from <code>right</code> where keys match that in <code>left</code>. If there are no such rows in <code>right</code>, an NA value is used for every selected field from right.</p><pre><code class="language-julia-repl">julia&gt; join(l,r, how=:left)
Table with 4 rows, 4 columns:
a  b  c  d
────────────
1  1  1  2
1  2  2  3
2  1  3  #NA
2  2  4  #NA</code></pre><p><strong>Outer join</strong></p><p>Outer (aka Union) join looks up rows from <code>right</code> where keys match that in <code>left</code>, and also rows from <code>left</code> where keys match those in <code>left</code>, if there are no matches on either side, a tuple of NA values is used. The output is guarranteed to contain the union of all keys from both tables.</p><pre><code class="language-julia-repl">julia&gt; join(l,r, how=:outer)
Table with 6 rows, 4 columns:
a  b  c    d
──────────────
0  1  #NA  1
1  1  1    2
1  2  2    3
2  1  3    #NA
2  2  4    #NA
3  2  #NA  4</code></pre><p><strong>Anti join</strong></p><p>Anti join keeps rows in <code>left</code> whose keys are NOT present in <code>right</code>.</p><pre><code class="language-julia-repl">julia&gt; join(l, r, how=:anti)
Table with 2 rows, 3 columns:
a  b  c
───────
2  1  3
2  2  4</code></pre><p><strong>One-to-many and many-to-many matches</strong></p><p>If the same key appears multiple times in either table (say, <code>m</code> and <code>n</code> times respectively), each row with a key from <code>left</code> is matched with each row from <code>right</code> with that key (resulting in <code>m×n</code> output rows with the same key.)</p><pre><code class="language-julia-repl">julia&gt; l1 = table([1,2,2,3], [1,2,3,4], names=[:x,:y])
Table with 4 rows, 2 columns:
x  y
────
1  1
2  2
2  3
3  4

julia&gt; r1 = table([2,2,3,3], [5,6,7,8], names=[:x,:z])
Table with 4 rows, 2 columns:
x  z
────
2  5
2  6
3  7
3  8

julia&gt; join(l1,r1, lkey=:x, rkey=:x)
Table with 6 rows, 3 columns:
x  y  z
───────
2  2  5
2  2  6
2  3  5
2  3  6
3  4  7
3  4  8</code></pre><p>This applies to all joins described above except anti join where rows are not matched.</p><p><strong>Options</strong></p><ul><li><p><code>how::Symbol</code> – join method to use. Described above.</p></li><li><p><code>lkey::Selection</code> – fields from <code>left</code> to match on</p></li><li><p><code>rkey::Selection</code> – fields from <code>right</code> to match on</p></li><li><p><code>lselect::Selection</code> – fields from <code>left</code> to use as output columns, or input to <code>f</code> if it is specified. By default, this is all fields not selected in <code>lkey</code>.</p></li><li><p><code>rselect::Selection</code> – fields from <code>right</code> to use as output columns, or input to <code>f</code> if it is specified. By default, this is all fields not selected in <code>rkey</code>.</p></li></ul><p>See <code>select</code> for a description of <code>Selection</code> type.</p><pre><code class="language-julia-repl">julia&gt; join(l, r, lkey=:a, rkey=:a,
            lselect=:b, rselect=:d, how=:outer)
Table with 8 rows, 3 columns:
a  b    d
───────────
0  #NA  1
1  1    2
1  1    3
1  2    2
1  2    3
2  1    #NA
2  2    #NA
3  #NA  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/f5de7ae837b43f5e2dddaacc5d1fbc59a30a72db/src/join.jl#L246-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.groupjoin" href="#IndexedTables.groupjoin"><code>IndexedTables.groupjoin</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>groupjoin([f, ] left, right; how, &lt;options&gt;)</code></p><p>Join <code>left</code> and <code>right</code> creating groups of values with matching keys.</p><p><strong>Inner join</strong></p><p>Inner join is the default join (when <code>how</code> is unspecified). It looks up keys from <code>left</code> in <code>right</code> and only joins them when there is a match. This generates the &quot;intersection&quot; of keys from <code>left</code> and <code>right</code>.</p><p><strong>One-to-many and many-to-many matches</strong></p><p>If the same key appears multiple times in either table (say, <code>m</code> and <code>n</code> times respectively), each row with a key from <code>left</code> is matched with each row from <code>right</code> with that key. The resulting group has <code>m×n</code> output elements.</p><pre><code class="language-julia-repl">julia&gt; l = table([1,1,1,2], [1,2,2,1], [1,2,3,4],
                 names=[:a,:b,:c], pkey=(:a, :b))
Table with 4 rows, 3 columns:
a  b  c
───────
1  1  1
1  2  2
1  2  3
2  1  4

julia&gt; r = table([0,1,1,2], [1,2,2,1], [1,2,3,4],
                 names=[:a,:b,:d], pkey=(:a, :b))
Table with 4 rows, 3 columns:
a  b  d
───────
0  1  1
1  2  2
1  2  3
2  1  4

julia&gt; groupjoin(l,r)
Table with 2 rows, 3 columns:
a  b  groups
──────────────────────────────────────────────────────────────────────────────────────────────────────
1  2  NamedTuples._NT_c_d{Int64,Int64}[(c = 2, d = 2), (c = 2, d = 3), (c = 3, d = 2), (c = 3, d = 3)]
2  1  NamedTuples._NT_c_d{Int64,Int64}[(c = 4, d = 4)]</code></pre><p><strong>Left join</strong></p><p>Left join looks up rows from <code>right</code> where keys match that in <code>left</code>. If there are no such rows in <code>right</code>, an NA value is used for every selected field from right.</p><pre><code class="language-julia-repl">julia&gt; groupjoin(l,r, how=:left)
Table with 3 rows, 3 columns:
a  b  groups
──────────────────────────────────────────────────────────────────────────────────────────────────────
1  1  NamedTuples._NT_c_d{Int64,Int64}[]
1  2  NamedTuples._NT_c_d{Int64,Int64}[(c = 2, d = 2), (c = 2, d = 3), (c = 3, d = 2), (c = 3, d = 3)]
2  1  NamedTuples._NT_c_d{Int64,Int64}[(c = 4, d = 4)]</code></pre><p><strong>Outer join</strong></p><p>Outer (aka Union) join looks up rows from <code>right</code> where keys match that in <code>left</code>, and also rows from <code>left</code> where keys match those in <code>left</code>, if there are no matches on either side, a tuple of NA values is used. The output is guarranteed to contain </p><pre><code class="language-julia-repl">
julia&gt; groupjoin(l,r, how=:outer)
Table with 4 rows, 3 columns:
a  b  groups
──────────────────────────────────────────────────────────────────────────────────────────────────────
0  1  NamedTuples._NT_c_d{Int64,Int64}[]
1  1  NamedTuples._NT_c_d{Int64,Int64}[]
1  2  NamedTuples._NT_c_d{Int64,Int64}[(c = 2, d = 2), (c = 2, d = 3), (c = 3, d = 2), (c = 3, d = 3)]
2  1  NamedTuples._NT_c_d{Int64,Int64}[(c = 4, d = 4)]</code></pre><p><strong>Options</strong></p><ul><li><p><code>how::Symbol</code> – join method to use. Described above.</p></li><li><p><code>lkey::Selection</code> – fields from <code>left</code> to match on</p></li><li><p><code>rkey::Selection</code> – fields from <code>right</code> to match on</p></li><li><p><code>lselect::Selection</code> – fields from <code>left</code> to use as input to use as output columns, or input to <code>f</code> if it is specified. By default, this is all fields not selected in <code>lkey</code>.</p></li><li><p><code>rselect::Selection</code> – fields from <code>left</code> to use as input to use as output columns, or input to <code>f</code> if it is specified. By default, this is all fields not selected in <code>rkey</code>.</p></li></ul><pre><code class="language-julia-repl">julia&gt; groupjoin(l,r, lkey=:a, rkey=:a, lselect=:c, rselect=:d, how=:outer)
Table with 3 rows, 2 columns:
a  groups
───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
0  NamedTuples._NT_c_d{Int64,Int64}[]
1  NamedTuples._NT_c_d{Int64,Int64}[(c = 1, d = 2), (c = 1, d = 3), (c = 2, d = 2), (c = 2, d = 3), (c = 3, d = 2), (c = 3, d = 3)]
2  NamedTuples._NT_c_d{Int64,Int64}[(c = 4, d = 4)]</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/f5de7ae837b43f5e2dddaacc5d1fbc59a30a72db/src/join.jl#L500-L589">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin" href="#IndexedTables.asofjoin"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>asofjoin(left::NDSparse, right::NDSparse)</code></p><p>asofjoin is most useful on two time-series. It joins rows from <code>left</code> with the &quot;most recent&quot; value from <code>right</code>.</p><pre><code class="language-julia-repl">julia&gt; x = ndsparse(([&quot;ko&quot;,&quot;ko&quot;, &quot;xrx&quot;,&quot;xrx&quot;],
                     Date.([&quot;2017-11-11&quot;, &quot;2017-11-12&quot;,
                            &quot;2017-11-11&quot;, &quot;2017-11-12&quot;])), [1,2,3,4]);

julia&gt; y = ndsparse(([&quot;ko&quot;,&quot;ko&quot;, &quot;xrx&quot;,&quot;xrx&quot;],
                     Date.([&quot;2017-11-12&quot;, &quot;2017-11-13&quot;,
                            &quot;2017-11-10&quot;, &quot;2017-11-13&quot;])), [5,6,7,8])

julia&gt; asofjoin(x,y)
2-d NDSparse with 4 values (Int64):
1      2          │
──────────────────┼──
&quot;ko&quot;   2017-11-11 │ 1
&quot;ko&quot;   2017-11-12 │ 5
&quot;xrx&quot;  2017-11-11 │ 7
&quot;xrx&quot;  2017-11-12 │ 7</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/f5de7ae837b43f5e2dddaacc5d1fbc59a30a72db/src/join.jl#L637-L662">source</a></section><h2><a class="nav-anchor" id="Merge-1" href="#Merge-1">Merge</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge" href="#Base.merge"><code>Base.merge</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Merge two NamedTuples favoring the lhs Order is preserved lhs names come first. This copies the underlying data.</p></div><a class="source-link" target="_blank" href="https://github.com/blackrock/NamedTuples.jl/blob/33f5f1397fe93ed329c80dacfaf77e3c0d99e505/src/NamedTuples.jl#L312">source</a><div><p><code>merge(a::Union{Table, NDSparse}, a::Union{Table, NDSparse})</code></p><p>Merge rows from two datasets while keeping them ordered by primary keys.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; a = table([1,3,5], [1,2,3], names=[:x,:y], pkey=:x)
Table with 3 rows, 2 columns:
x  y
────
1  1
3  2
5  3

julia&gt; b = table([2,3,4], [1,2,3], names=[:x,:y], pkey=:x)
Table with 3 rows, 2 columns:
x  y
────
2  1
3  2
4  3

julia&gt; merge(a,b)
Table with 6 rows, 2 columns:
x  y
────
1  1
2  1
3  2
3  2
4  3
5  3
</code></pre><p>When merging two NDSparse objects, if the same key is present in both inputs, the value from the second input is chosen.</p><pre><code class="language-julia-repl">julia&gt; a = ndsparse([1,3,5], [1,2,3]);

julia&gt; b = ndsparse([2,3,4], [1,2,3]);

julia&gt; merge(a,b)
1-d NDSparse with 5 values (Int64):
1 │
──┼──
1 │ 1
2 │ 1
3 │ 2
4 │ 3
5 │ 3
</code></pre><p>However, you can pass the <code>agg</code> keyword argument to combine the values with a custom function.</p><pre><code class="language-julia-repl">julia&gt; merge(a,b,agg=+)
1-d NDSparse with 5 values (Int64):
1 │
──┼──
1 │ 1
2 │ 1
3 │ 4
4 │ 3
5 │ 3</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/f5de7ae837b43f5e2dddaacc5d1fbc59a30a72db/src/join.jl#L793-L862">source</a></section><h2><a class="nav-anchor" id="Broadcast-1" href="#Broadcast-1">Broadcast</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.broadcast-Tuple{Function,IndexedTables.NDSparse,IndexedTables.NDSparse}" href="#Base.broadcast-Tuple{Function,IndexedTables.NDSparse,IndexedTables.NDSparse}"><code>Base.broadcast</code></a> — <span class="docstring-category">Method</span>.</div><div><p><code>broadcast(f::Function, A::NDSparse, B::NDSparse; dimmap::Tuple{Vararg{Int}})</code></p><p>Compute an inner join of <code>A</code> and <code>B</code> using function <code>f</code>, where the dimensions of <code>B</code> are a subset of the dimensions of <code>A</code>. Values from <code>B</code> are repeated over the extra dimensions.</p><p><code>dimmap</code> optionally specifies how dimensions of <code>A</code> correspond to dimensions of <code>B</code>. It is a tuple where <code>dimmap[i]==j</code> means the <code>i</code>th dimension of <code>A</code> matches the <code>j</code>th dimension of <code>B</code>. Extra dimensions that do not match any dimensions of <code>j</code> should have <code>dimmap[i]==0</code>.</p><p>If <code>dimmap</code> is not specified, it is determined automatically using index column names and types.</p><pre><code class="language-julia-repl">julia&gt; a = ndsparse(([1,1,2,2], [1,2,1,2]), [1,2,3,4])
2-d NDSparse with 4 values (Int64):
1  2 │
─────┼──
1  1 │ 1
1  2 │ 2
2  1 │ 3
2  2 │ 4

julia&gt; b = ndsparse([1,2], [1/1, 1/2])
1-d NDSparse with 2 values (Float64):
1 │
──┼────
1 │ 1.0
2 │ 0.5

julia&gt; broadcast(*, a, b)
2-d NDSparse with 4 values (Float64):
1  2 │
─────┼────
1  1 │ 1.0
1  2 │ 2.0
2  1 │ 1.5
2  2 │ 2.0</code></pre><p>The <code>.</code>-broadcast syntax works with NDSparse:</p><pre><code class="language-julia-repl">julia&gt; a.*b
2-d NDSparse with 4 values (Float64):
1  2 │
─────┼────
1  1 │ 1.0
1  2 │ 2.0
2  1 │ 1.5
2  2 │ 2.0</code></pre><p><code>dimmap</code> maps dimensions that should be broadcasted:</p><pre><code class="language-julia-repl">
julia&gt; broadcast(*, a, b, dimmap=(0,1))
2-d NDSparse with 4 values (Float64):
1  2 │
─────┼────
1  1 │ 1.0
1  2 │ 1.0
2  1 │ 3.0
2  2 │ 2.0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/f5de7ae837b43f5e2dddaacc5d1fbc59a30a72db/src/join.jl#L1036-L1104">source</a></section><footer><hr/><a class="previous" href="aggregation.html"><span class="direction">Previous</span><span class="title">Aggregation</span></a><a class="next" href="io.html"><span class="direction">Next</span><span class="title">Loading and Saving</span></a></footer></article></body></html>
