<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · JuliaDB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuliaDB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Manual</a></li><li class="current"><a class="toctext" href="apireference.html">API Reference</a><ul class="internal"><li><a class="toctext" href="#DNDSparse-1">DNDSparse</a></li><li><a class="toctext" href="#Loading-data-1">Loading data</a></li><li><a class="toctext" href="#Saving-and-Loading-tables-1">Saving and Loading tables</a></li><li><a class="toctext" href="#distributing-an-NDSparse-1">distributing an NDSparse</a></li><li><a class="toctext" href="#Compute-and-collect-1">Compute and collect</a></li><li><a class="toctext" href="#Indexing-1">Indexing</a></li><li><a class="toctext" href="#Queries-1">Queries</a></li><li><a class="toctext" href="#Joins-1">Joins</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="apireference.html">API Reference</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/master/docs/src/apireference.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API Reference</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-documentation-1" href="#API-documentation-1">API documentation</a></h1><h2><a class="nav-anchor" id="DNDSparse-1" href="#DNDSparse-1">DNDSparse</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.DNDSparse" href="#JuliaDB.DNDSparse"><code>JuliaDB.DNDSparse</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A distributed NDSparse datastructure. Can be constructed using <a href="@ref">loadfiles</a>, <a href="@ref">ingest</a> or <a href="@ref">distribute</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/dndsparse.jl#L10-L14">source</a></section><h2><a class="nav-anchor" id="Loading-data-1" href="#Loading-data-1">Loading data</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest" href="#JuliaDB.ingest"><code>JuliaDB.ingest</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest(files::Union{AbstractVector,String}, outputdir::AbstractString; &lt;options&gt;...)</code></pre><p>ingests data from CSV files into JuliaDB. Stores the metadata and index in a directory <code>outputdir</code>. Creates <code>outputdir</code> if it doesn&#39;t exist.</p><p>All keyword arguments are passed to loadfiles. <code>delim</code> is a keyword argument to <code>ingest</code> – this is the delimiter in CSV reading.</p><p>Equivalent to calling <code>loadfiles</code> and then <code>save</code> on the result of <code>loadfiles</code>. See also <a href="apireference.html#JuliaDB.loadfiles"><code>loadfiles</code></a> and <a href="apireference.html#Dagger.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/io.jl#L235-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.ingest!" href="#JuliaDB.ingest!"><code>JuliaDB.ingest!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ingest!(files::Union{AbstractVector,String}, inputdir::AbstractString, outpudir=inputdir; delim=&#39;,&#39;, chunks=1, &lt;options&gt;...)</code></pre><p>load data from <code>files</code> and add it to data stored in <code>inputdir</code>. If <code>outputdir</code> is specified, the resulting table will be written to this directory. By default, this will create a single chunk and append it. Pass <code>chunks</code> argument to specify how many chunks the new data should be loaded as.</p><p>See also <a href="@ingest"><code>ingest</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/io.jl#L251-L257">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="JuliaDB.loadfiles" href="#JuliaDB.loadfiles"><code>JuliaDB.loadfiles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">loadfiles(files::Union{AbstractVector,String}, delim = &#39;,&#39;; &lt;options&gt;)</code></pre><p>Load a collection of CSV <code>files</code> into a DNDSparse, where <code>files</code> is either a vector of file paths, or the path of a directory containing files to load.</p><p><strong>Arguments:</strong></p><ul><li><p><code>usecache::Bool</code>: use cached metadata from previous loads while loading the files. Set this to <code>false</code> if you are changing other options.</p></li></ul><p>All other arguments options are the same as those listed in <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/io.jl#L32-L45">source</a></section><h2><a class="nav-anchor" id="Saving-and-Loading-tables-1" href="#Saving-and-Loading-tables-1">Saving and Loading tables</a></h2><p>Saving an existing <code>DNDSparse</code> can be accomplished through the use of the <code>save</code> function.  The <code>save</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.save" href="#Dagger.save"><code>Dagger.save</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">save(t::DNDSparse, outputdir::AbstractString)</code></pre><p>Saves a <code>DNDSparse</code> to disk. This function blocks till all chunks have been computed and saved. Saved data can be loaded with <code>load</code>.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="apireference.html#Dagger.load"><code>load</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/io.jl#L303-L311">source</a></section><p>Loading a previously saved <code>DNDSparse</code> from disk can be accomplished through use of the <code>load</code> function.  The <code>load</code> function has the following help string:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.load" href="#Dagger.load"><code>Dagger.load</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">load(dir::AbstractString; tomemory)</code></pre><p>Load a saved <code>DNDSparse</code> from <code>dir</code> directory. Data can be saved using <code>ingest</code> or <code>save</code> functions. If <code>tomemory</code> option is true, then data is loaded into memory rather than mmapped.</p><p>See also <a href="apireference.html#JuliaDB.ingest"><code>ingest</code></a>, <a href="apireference.html#Dagger.save"><code>save</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/io.jl#L287-L295">source</a></section><h2><a class="nav-anchor" id="distributing-an-NDSparse-1" href="#distributing-an-NDSparse-1">distributing an NDSparse</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.distribute" href="#Dagger.distribute"><code>Dagger.distribute</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">distribute(t::Table, chunks)</code></pre><p>Distribute a table in <code>chunks</code> pieces. Equivalent to <code>table(t, chunks=chunks)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/table/table.jl#L151-L155">source</a><div><pre><code class="language-none">distribute(itable::NDSparse, rowgroups::AbstractArray)</code></pre><p>Distributes an NDSparse object into a DNDSparse by splitting it up into chunks of <code>rowgroups</code> elements. <code>rowgroups</code> is a vector specifying the number of rows in the chunks.</p><p>Returns a <code>DNDSparse</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/dndsparse.jl#L396-L404">source</a><div><pre><code class="language-none">distribute(itable::NDSparse, nchunks::Int=nworkers())</code></pre><p>Distributes an NDSparse object into a DNDSparse of <code>nchunks</code> chunks of approximately equal size.</p><p>Returns a <code>DNDSparse</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/dndsparse.jl#L425-L432">source</a></section><h2><a class="nav-anchor" id="Compute-and-collect-1" href="#Compute-and-collect-1">Compute and collect</a></h2><p>Operations in JuliaDB are out-of-core in nature. They return <code>DNDSparse</code> objects which can contain parts that are not yet evaluated. <code>compute</code> and <code>collect</code> are ways to force evaluation.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Dagger.compute-Tuple{JuliaDB.DNDSparse}" href="#Dagger.compute-Tuple{JuliaDB.DNDSparse}"><code>Dagger.compute</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute(t::DNDSparse; allowoverlap, closed)</code></pre><p>Computes any delayed-evaluations in the <code>DNDSparse</code>. The computed data is left on the worker processes. Subsequent operations on the results will reuse the chunks.</p><p>If <code>allowoverlap</code> is false then the computed data is re-sorted if required to have no chunks with overlapping index ranges if necessary.</p><p>If <code>closed</code> is true then the computed data is re-sorted if required to have no chunks with overlapping OR continuous boundaries.</p><p>See also <a href="apireference.html#Base.collect-Tuple{JuliaDB.DNDSparse}"><code>collect</code></a>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>compute(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. You usually don&#39;t need to do this for the whole dataset. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="apireference.html#Dagger.save"><code>save</code></a> for more.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/dndsparse.jl#L86-L106">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.collect-Tuple{JuliaDB.DNDSparse}" href="#Base.collect-Tuple{JuliaDB.DNDSparse}"><code>Base.collect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">collect(t::DNDSparse)</code></pre><p>Gets distributed data in a DNDSparse <code>t</code> and merges it into <a href="#IndexedTables.NDSparse">NDSparse</a> object</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>collect(t)</code> requires at least as much memory as the size of the result of the computing <code>t</code>. If the result is expected to be big, try <code>compute(save(t, &quot;output_dir&quot;))</code> instead. See <a href="apireference.html#Dagger.save"><code>save</code></a> for more. This data can be loaded later using <a href="apireference.html#Dagger.load"><code>load</code></a>.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/dndsparse.jl#L128-L139">source</a></section><h2><a class="nav-anchor" id="Indexing-1" href="#Indexing-1">Indexing</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.getindex-Tuple{JuliaDB.DNDSparse,Vararg{Any,N} where N}" href="#Base.getindex-Tuple{JuliaDB.DNDSparse,Vararg{Any,N} where N}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">t[idx...]</code></pre><p>Returns a <code>DNDSparse</code> containing only the elements of <code>t</code> where the given indices (<code>idx</code>) match. If <code>idx</code> has the same type as the index tuple of the <code>t</code>, then this is considered a scalar indexing (indexing of a single value). In this case the value itself is looked up and returned.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/indexing.jl#L2-L10">source</a></section><h2><a class="nav-anchor" id="Queries-1" href="#Queries-1">Queries</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select-Tuple{JuliaDB.DNDSparse,Vararg{Pair,N} where N}" href="#Base.Sort.select-Tuple{JuliaDB.DNDSparse,Vararg{Pair,N} where N}"><code>Base.Sort.select</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">select(t::DNDSparse, conditions::Pair...)</code></pre><p>Filter based on index columns. Conditions are accepted as column-function pairs.</p><p>Example: <code>select(t, 1 =&gt; x-&gt;x&gt;10, 3 =&gt; x-&gt;x!=10 ...)</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L9-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select-Tuple{JuliaDB.DNDSparse,Vararg{Union{Int64, Symbol},N} where N}" href="#Base.Sort.select-Tuple{JuliaDB.DNDSparse,Vararg{Union{Int64, Symbol},N} where N}"><code>Base.Sort.select</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">select(t::DNDSparse, which...; agg)</code></pre><p>Returns a new DNDSparse where only a subset of the index columns (specified by <code>which</code>) are kept.</p><p>The <code>agg</code> keyword argument is a function which specifies how entries with equal indices should be aggregated. If <code>agg</code> is unspecified, then the repeating indices are kept in the output, you can then aggregate using <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DNDSparse}"><code>aggregate</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L20-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate-Tuple{Any,JuliaDB.DNDSparse}" href="#IndexedTables.aggregate-Tuple{Any,JuliaDB.DNDSparse}"><code>IndexedTables.aggregate</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">aggregate(f, t::DNDSparse)</code></pre><p>Combines adjacent rows with equal indices using the given 2-argument reduction function <code>f</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L55-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DNDSparse}" href="#IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DNDSparse}"><code>IndexedTables.aggregate_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">aggregate_vec(f::Function, x::DNDSparse)</code></pre><p>Combine adjacent rows with equal indices using a function from vector to scalar, e.g. <code>mean</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L72-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter-Tuple{Any,JuliaDB.DNDSparse}" href="#Base.filter-Tuple{Any,JuliaDB.DNDSparse}"><code>Base.filter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">filter(f, t::DNDSparse)</code></pre><p>Filters <code>t</code> removing rows for which <code>f</code> is false. <code>f</code> is passed only the data and not the index.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L86-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.convertdim-Tuple{JuliaDB.DNDSparse,Union{Int64, Symbol},Any}" href="#IndexedTables.convertdim-Tuple{JuliaDB.DNDSparse,Union{Int64, Symbol},Any}"><code>IndexedTables.convertdim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">convertdim(x::DNDSparse, d::DimName, xlate; agg::Function, name)</code></pre><p>Apply function or dictionary <code>xlate</code> to each index in the specified dimension. If the mapping is many-to-one, <code>agg</code> is used to aggregate the results. <code>name</code> optionally specifies a name for the new dimension. <code>xlate</code> must be a monotonically increasing function.</p><p>See also <a href="apireference.html#Base.reducedim-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>reducedim</code></a> and <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DNDSparse}"><code>aggregate</code></a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L96-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.reducedim-Tuple{Any,JuliaDB.DNDSparse,Any}" href="#Base.reducedim-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>Base.reducedim</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reducedim(f, t::DNDSparse, dims)</code></pre><p>Remove <code>dims</code> dimensions from <code>t</code>, aggregate any rows with equal indices using 2-argument function <code>f</code>.</p><p>See also <a href="apireference.html#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>reducedim_vec</code></a>, <a href="apireference.html#Base.Sort.select-Tuple{JuliaDB.DNDSparse,Vararg{Pair,N} where N}"><code>select</code></a> and <a href="apireference.html#IndexedTables.aggregate-Tuple{Any,JuliaDB.DNDSparse}"><code>aggregate</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L143-L150">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}" href="#IndexedTables.reducedim_vec-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>IndexedTables.reducedim_vec</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">reducedim_vec(f::Function, t::DNDSparse, dims)</code></pre><p>Like <code>reducedim</code>, except uses a function mapping a vector of values to a scalar instead of a 2-argument scalar function.</p><p>See also <a href="apireference.html#Base.reducedim-Tuple{Any,JuliaDB.DNDSparse,Any}"><code>reducedim</code></a> and <a href="apireference.html#IndexedTables.aggregate_vec-Tuple{Any,JuliaDB.DNDSparse}"><code>aggregate_vec</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/query.jl#L161-L167">source</a></section><h2><a class="nav-anchor" id="Joins-1" href="#Joins-1">Joins</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.naturaljoin-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}" href="#IndexedTables.naturaljoin-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}"><code>IndexedTables.naturaljoin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">naturaljoin(left::DNDSparse, right::DNDSparse, [op])</code></pre><p>Returns a new <code>DNDSparse</code> containing only rows where the indices are present both in <code>left</code> AND <code>right</code> tables. The data columns are concatenated.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/join.jl#L6-L11">source</a></section><pre><code class="language-none">leftjoin{K,V}(left::DNDSparse{K,V}, right::DNDSparse)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.asofjoin-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}" href="#IndexedTables.asofjoin-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}"><code>IndexedTables.asofjoin</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">asofjoin(left::DNDSparse, right::DNDSparse)</code></pre><p>Keeps the indices of <code>left</code> but uses the value from <code>right</code> corresponding to highest index less than or equal to that of left.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/join.jl#L114-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.merge-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}" href="#Base.merge-Tuple{JuliaDB.DNDSparse,JuliaDB.DNDSparse}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">merge(left::DNDSparse, right::DNDSparse; agg)</code></pre><p>Merges <code>left</code> and <code>right</code> combining rows with matching indices using <code>agg</code>. By default <code>agg</code> picks the value from <code>right</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/cc9358ca0505760c2f1dee7ab46a344a5f2da0a5/src/join.jl#L124-L129">source</a></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Manual</span></a></footer></article></body></html>
