<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Selection · JuliaDB</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/custom.js"></script></head><body><nav class="toc"><h1>JuliaDB</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><a class="toctext" href="index.html">API Reference</a></li><li><a class="toctext" href="datastructures.html">Data Structures</a></li><li class="current"><a class="toctext" href="selection.html">Selection</a><ul class="internal"><li><a class="toctext" href="#Select-1">Select</a></li><li><a class="toctext" href="#Map-1">Map</a></li><li><a class="toctext" href="#Filter-1">Filter</a></li><li><a class="toctext" href="#AoS-and-SoA-1">AoS and SoA</a></li><li><a class="toctext" href="#Column-modification-1">Column modification</a></li><li><a class="toctext" href="#Column-special-selection-1">Column special selection</a></li></ul></li><li><a class="toctext" href="aggregation.html">Aggregation</a></li><li><a class="toctext" href="joins.html">Joins</a></li><li><a class="toctext" href="reshaping.html">Reshaping</a></li><li><a class="toctext" href="io.html">Loading and Saving</a></li><li><a class="toctext" href="plotting.html">Plotting</a></li><li><a class="toctext" href="../manual/onlinestats.html">OnlineStats Integration</a></li><li><a class="toctext" href="../manual/out-of-core.html">Out-of-core functionality</a></li><li><a class="toctext" href="../manual/ml.html">Feature Extraction</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="selection.html">Selection</a></li></ul><a class="edit-page" href="https://github.com/JuliaComputing/JuliaDB.jl/blob/master/docs/src/api/selection.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Selection</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Selection-1" href="#Selection-1">Selection</a></h1><p>Select, transform and filter a table.</p><h2><a class="nav-anchor" id="Select-1" href="#Select-1">Select</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.Sort.select" href="#Base.Sort.select"><code>Base.Sort.select</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>select(t::Table, which::Selection)</code></p><p>Select all or a subset of columns, or a single column from the table.</p><p><code>Selection</code> is a type union of many types that can select from a table. It can be:</p><ol><li><p><code>Integer</code> – returns the column at this position.</p></li><li><p><code>Symbol</code> – returns the column with this name.</p></li><li><p><code>Pair{Selection =&gt; Function}</code> – selects and maps a function over the selection, returns the result.</p></li><li><p><code>AbstractArray</code> – returns the array itself. This must be the same length as the table.</p></li><li><p><code>Tuple</code> of <code>Selection</code> – returns a table containing a column for every selector in the tuple. The tuple may also contain the type <code>Pair{Symbol, Selection}</code>, which the selection a name. The most useful form of this when introducing a new column.</p></li></ol><p><strong>Examples:</strong></p><p>Selection with <code>Integer</code> – returns the column at this position.</p><pre><code class="language-julia-repl">julia&gt; tbl = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; select(tbl, 2)
2-element Array{Int64,1}:
 2
 1
</code></pre><p>Selection with <code>Symbol</code> – returns the column with this name.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, :t)
2-element Array{Float64,1}:
 0.01
 0.05
</code></pre><p>Selection with <code>Pair{Selection =&gt; Function}</code> – selects some columns and maps a function over it, then returns the mapped column.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, :t=&gt;t-&gt;1/t)
2-element Array{Float64,1}:
 100.0
  20.0
</code></pre><p>Selection with <code>AbstractArray</code> – returns the array itself.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, [3,4])
2-element Array{Int64,1}:
 3
 4
</code></pre><p>Selection with <code>Tuple</code>– returns a table containing a column for every selector in the tuple.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, (2,1))
Table with 2 rows, 2 columns:
x  t
───────
2  0.01
1  0.05

julia&gt; vx = select(tbl, (:x, :t)=&gt;p-&gt;p.x/p.t)
2-element Array{Float64,1}:
 200.0
  20.0

julia&gt; select(tbl, (:x,:t=&gt;-))
Table with 2 rows, 2 columns:
x  t
────────
1  -0.05
2  -0.01</code></pre><p>Note that since <code>tbl</code> was initialized with <code>t</code> as the primary key column, selections that retain the key column will retain its status as a key. The same applies when multiple key columns are selected.</p><p>Selection with a custom array in the tuple will cause the name of the columns to be removed and replaced with integers.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, (:x, :t, [3,4]))
Table with 2 rows, 3 columns:
1  2     3
──────────
2  0.01  3
1  0.05  4</code></pre><p>This is because the third column&#39;s name is unknown. In general if a column&#39;s name cannot be determined, then selection returns an iterable of tuples rather than named tuples. In other words, it strips column names.</p><p>To specify a new name to a custom column, you can use <code>Symbol =&gt; Selection</code> selector.</p><pre><code class="language-julia-repl">julia&gt; select(tbl, (:x,:t,:z=&gt;[3,4]))
Table with 2 rows, 3 columns:
x  t     z
──────────
2  0.01  3
1  0.05  4

julia&gt; select(tbl, (:x, :t, :minust=&gt;:t=&gt;-))
Table with 2 rows, 3 columns:
x  t     minust
───────────────
2  0.01  -0.01
1  0.05  -0.05

julia&gt; select(tbl, (:x, :t, :vx=&gt;(:x,:t)=&gt;p-&gt;p.x/p.t))
Table with 2 rows, 3 columns:
x  t     vx
──────────────
2  0.01  200.0
1  0.05  20.0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/selection.jl#L3-L129">source</a></section><h2><a class="nav-anchor" id="Map-1" href="#Map-1">Map</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,IndexedTables.NextTable}" href="#Base.map-Tuple{Any,IndexedTables.NextTable}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><p><code>map(f, t::Table; select)</code></p><p>Apply <code>f</code> to every row in <code>t</code>. <code>select</code> selects fields passed to <code>f</code>.</p><p>Returns a new table if <code>f</code> returns a tuple or named tuple. If not, returns a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [1,2], [3,4], names=[:t, :x, :y])
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  1  3
0.05  2  4

julia&gt; manh = map(row-&gt;row.x + row.y, t)
2-element Array{Int64,1}:
 4
 6

julia&gt; polar = map(p-&gt;@NT(r=hypot(p.x + p.y), θ=atan2(p.y, p.x)), t)
Table with 2 rows, 2 columns:
r    θ
────────────
4.0  1.24905
6.0  1.10715
</code></pre><p><code>select</code> argument selects a subset of columns while iterating.</p><pre><code class="language-julia-repl">
julia&gt; vx = map(row-&gt;row.x/row.t, t, select=(:t,:x)) # row only cotains t and x
2-element Array{Float64,1}:
 100.0
  40.0

julia&gt; map(sin, polar, select=:θ)
2-element Array{Float64,1}:
 0.948683
 0.894427
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/selection.jl#L212-L260">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.map-Tuple{Any,IndexedTables.NDSparse}" href="#Base.map-Tuple{Any,IndexedTables.NDSparse}"><code>Base.map</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">map(f, x::NDSparse; select)</code></pre><p>Apply <code>f</code> to every data value in <code>x</code>. <code>select</code> selects fields passed to <code>f</code>. By default, the data values are selected.</p><p>If the return value of <code>f</code> is a tuple or named tuple the result will contain many data columns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; x = ndsparse(@NT(t=[0.01, 0.05]), @NT(x=[1,2], y=[3,4]))
1-d NDSparse with 2 values (2 field named tuples):
t    │ x  y
─────┼─────
0.01 │ 1  3
0.05 │ 2  4

julia&gt; manh = map(row-&gt;row.x + row.y, x)
1-d NDSparse with 2 values (Int64):
t    │
─────┼──
0.01 │ 4
0.05 │ 6

julia&gt; vx = map(row-&gt;row.x/row.t, x, select=(:t,:x))
1-d NDSparse with 2 values (Float64):
t    │
─────┼──────
0.01 │ 100.0
0.05 │ 40.0

julia&gt; polar = map(p-&gt;@NT(r=hypot(p.x + p.y), θ=atan2(p.y, p.x)), x)
1-d NDSparse with 2 values (2 field named tuples):
t    │ r    θ
─────┼─────────────
0.01 │ 4.0  1.24905
0.05 │ 6.0  1.10715

julia&gt; map(sin, polar, select=:θ)
1-d NDSparse with 2 values (Float64):
t    │
─────┼─────────
0.01 │ 0.948683
0.05 │ 0.894427
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/ndsparse.jl#L432-L480">source</a></section><h2><a class="nav-anchor" id="Filter-1" href="#Filter-1">Filter</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.filter" href="#Base.filter"><code>Base.filter</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>filter(pred, t::Union{NextTable, NDSparse}; select)</code></p><p>Filter rows in <code>t</code> according to <code>pred</code>. <code>select</code> choses the fields that act as input to <code>pred</code>.</p><p><code>pred</code> can be:</p><ul><li><p>A function - selected structs or values are passed to this function</p></li><li><p>A tuple of <code>column =&gt; function</code> pairs: applies to each named column the corresponding function, keeps only rows where all such conditions are satisfied.</p></li></ul><p>By default, <code>filter</code> iterates a table a row at a time:</p><pre><code class="language-julia-repl">julia&gt; t = table([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], [0.01, 0.05, 0.07], [2,1,0],
                 names=[:n, :t, :x])
Table with 3 rows, 3 columns:
n    t     x
────────────
&quot;a&quot;  0.01  2
&quot;b&quot;  0.05  1
&quot;c&quot;  0.07  0

julia&gt; filter(p-&gt;p.x/p.t &lt; 100, t) # whole row
Table with 2 rows, 3 columns:
n    t     x
────────────
&quot;b&quot;  0.05  1
&quot;c&quot;  0.07  0
</code></pre><p>By default, <code>filter</code> iterates by values of an <code>NDSparse</code>:</p><pre><code class="language-julia-repl">julia&gt; x = ndsparse(@NT(n=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], t=[0.01, 0.05, 0.07]), [2,1,0])
2-d NDSparse with 3 values (Int64):
n    t    │
──────────┼──
&quot;a&quot;  0.01 │ 2
&quot;b&quot;  0.05 │ 1
&quot;c&quot;  0.07 │ 0

julia&gt; filter(y-&gt;y&lt;2, x)
2-d NDSparse with 2 values (Int64):
n    t    │
──────────┼──
&quot;b&quot;  0.05 │ 1
&quot;c&quot;  0.07 │ 0</code></pre><p>If select is specified. (See <a href="api/@ref select">Selection convention</a>) then, the selected values will be iterated instead.</p><pre><code class="language-julia-repl">julia&gt; filter(iseven, t, select=:x)
Table with 2 rows, 3 columns:
n    t     x
────────────
&quot;a&quot;  0.01  2
&quot;c&quot;  0.07  0

julia&gt; filter(p-&gt;p.x/p.t &lt; 100, t, select=(:x,:t))
Table with 2 rows, 3 columns:
n    t     x
────────────
&quot;b&quot;  0.05  1
&quot;c&quot;  0.07  0</code></pre><p><code>select</code> works similarly for <code>NDSparse</code>:</p><pre><code class="language-julia-repl">julia&gt; filter(p-&gt;p[2]/p[1] &lt; 100, x, select=(:t, 3))
2-d NDSparse with 2 values (Int64):
n    t    │
──────────┼──
&quot;b&quot;  0.05 │ 1
&quot;c&quot;  0.07 │ 0</code></pre><p>Here 3 represents the third column, which is the values, <code>p</code> is a tuple of <code>t</code> field and the value.</p><p>Filtering by many single columns can be done by passing a tuple of <code>column_name =&gt; function</code> pairs.</p><pre><code class="language-julia-repl">julia&gt; filter((:x=&gt;iseven, :t=&gt;a-&gt;a&gt;0.01), t)
Table with 1 rows, 3 columns:
n    t     x
────────────
&quot;c&quot;  0.07  0

julia&gt; filter((3=&gt;iseven, :t=&gt;a-&gt;a&gt;0.01), x) # NDSparse
2-d NDSparse with 1 values (Int64):
n    t    │
──────────┼──
&quot;c&quot;  0.07 │ 0
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/selection.jl#L356-L451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DataValues.dropna" href="#DataValues.dropna"><code>DataValues.dropna</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>dropna(t[, select])</code></p><p>Drop rows which contain NA values.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.1, 0.5, NA,0.7], [2,NA,4,5], [NA,6,NA,7],
                  names=[:t,:x,:y])
Table with 4 rows, 3 columns:
t    x    y
─────────────
0.1  2    #NA
0.5  #NA  6
#NA  4    #NA
0.7  5    7

julia&gt; dropna(t)
Table with 1 rows, 3 columns:
t    x  y
─────────
0.7  5  7</code></pre><p>Optionally <code>select</code> can be speicified to limit columns to look for NAs in.</p><pre><code class="language-julia-repl">
julia&gt; dropna(t, :y)
Table with 2 rows, 3 columns:
t    x    y
───────────
0.5  #NA  6
0.7  5    7

julia&gt; t1 = dropna(t, (:t, :x))
Table with 2 rows, 3 columns:
t    x  y
───────────
0.1  2  #NA
0.7  5  7</code></pre><p>Any columns whose NA rows have been dropped will be converted to non-na array type. In our last example, columns <code>t</code> and <code>x</code> got converted from <code>Array{DataValue{Int}}</code> to <code>Array{Int}</code>. Similarly if the vectors are of type <code>DataValueArray{T}</code> (default for <code>loadtable</code>) they will be converted to <code>Array{T}</code>.</p><pre><code class="language-julia">julia&gt; typeof(column(dropna(t,:x), :x))
Array{Int64,1}</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/selection.jl#L296-L346">source</a></section><h2><a class="nav-anchor" id="AoS-and-SoA-1" href="#AoS-and-SoA-1">AoS and SoA</a></h2><p>This section describes extracting struct of arrays (<code>columns</code>) and array of structs (<code>rows</code>) from a table or an NDSparse. (Wikipedia entry on <a href="https://en.wikipedia.org/wiki/AOS_and_SOA">AoS and SoA</a>)</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.columns" href="#IndexedTables.columns"><code>IndexedTables.columns</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>columns(itr[, select::Selection])</code></p><p>Select one or more columns from an iterable of rows as a tuple of vectors.</p><p><code>select</code> specifies which columns to select. See <a href="selection.html#Base.Sort.select"><code>Selection convention</code></a> for possible values. If unspecified, returns all columns.</p><p><code>itr</code> can be <code>NDSparse</code>, <code>Columns</code> and <code>AbstractVector</code>, and their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,2],[3,4], names=[:x,:y])
Table with 2 rows, 2 columns:
x  y
────
1  3
2  4

julia&gt; columns(t)
(x = [1, 2], y = [3, 4])

julia&gt; columns(t, :x)
2-element Array{Int64,1}:
 1
 2

julia&gt; columns(t, (:x,))
(x = [1, 2])

julia&gt; columns(t, (:y,:x=&gt;-))
(y = [3, 4], x = [-1, -2])</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L122-L155">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.rows" href="#IndexedTables.rows"><code>IndexedTables.rows</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>rows(itr[, select::Selection])</code></p><p>Select one or more fields from an iterable of rows as a vector of their values.</p><p><code>select</code> specifies which fields to select. See <a href="selection.html#Base.Sort.select"><code>Selection convention</code></a> for possible values. If unspecified, returns all columns.</p><p><code>itr</code> can be <code>NDSparse</code>, <code>Columns</code> and <code>AbstractVector</code>, and their distributed counterparts.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,2],[3,4], names=[:x,:y])
Table with 2 rows, 2 columns:
x  y
────
1  3
2  4

julia&gt; rows(t)
2-element IndexedTables.Columns{NamedTuples._NT_x_y{Int64,Int64},NamedTuples._NT_x_y{Array{Int64,1},Array{Int64,1}}}:
 (x = 1, y = 3)
 (x = 2, y = 4)

julia&gt; rows(t, :x)
2-element Array{Int64,1}:
 1
 2

julia&gt; rows(t, (:x,))
2-element IndexedTables.Columns{NamedTuples._NT_x{Int64},NamedTuples._NT_x{Array{Int64,1}}}:
 (x = 1)
 (x = 2)

julia&gt; rows(t, (:y,:x=&gt;-))
2-element IndexedTables.Columns{NamedTuples._NT_y_x{Int64,Int64},NamedTuples._NT_y_x{Array{Int64,1},Array{Int64,1}}}:
 (y = 3, x = -1)
 (y = 4, x = -2)</code></pre><p>Note that vectors of tuples returned are <code>Columns</code> object and have columnar internal storage.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L764-L804">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.keys" href="#Base.keys"><code>Base.keys</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>keys(x::NDSparse[, select::Selection])</code></p><p>Get the keys of an <code>NDSparse</code> object. Same as <a href="selection.html#IndexedTables.rows"><code>rows</code></a> but acts only on the index columns of the <code>NDSparse</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/ndsparse.jl#L318-L322">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.values" href="#Base.values"><code>Base.values</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>values(x::NDSparse[, select::Selection])</code></p><p>Get the values of an <code>NDSparse</code> object. Same as <a href="selection.html#IndexedTables.rows"><code>rows</code></a> but acts only on the value columns of the <code>NDSparse</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/ndsparse.jl#L329-L333">source</a></section><h2><a class="nav-anchor" id="Column-modification-1" href="#Column-modification-1">Column modification</a></h2><p>This section describes functions that can modify the set of columns of a table. Note that these functions return new tables and doesn&#39;t mutate the existing table. This is done so that type information for a given table is always available and correct.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.setcol" href="#IndexedTables.setcol"><code>IndexedTables.setcol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>setcol(t::Table, col::Union{Symbol, Int}, x::Selection)</code></p><p>Sets a <code>x</code> as the column identified by <code>col</code>. Returns a new table.</p><p><code>setcol(t::Table, map::Pair...)</code></p><p>Set many columns at a time.</p><p><strong>Examples:</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,2], [3,4], names=[:x, :y])
Table with 2 rows, 2 columns:
x  y
────
1  3
2  4

julia&gt; setcol(t, 2, [5,6])
Table with 2 rows, 2 columns:
x  y
────
1  5
2  6
</code></pre><p><code>x</code> can be any selection that transforms existing columns.</p><pre><code class="language-julia-repl">julia&gt; setcol(t, :x, :x =&gt; x-&gt;1/x)
Table with 2 rows, 2 columns:
x    y
──────
1.0  5
0.5  6
</code></pre><p><code>setcol</code> will result in a re-sorted copy if a primary key column is replaced.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [1,2], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  1  3
0.05  2  4

julia&gt; t2 = setcol(t, :t, [0.1,0.05])
Table with 2 rows, 3 columns:
t     x  y
──────────
0.05  2  4
0.1   1  3

julia&gt; t == t2
false
</code></pre><p>If <code>col</code> is not an existing column, <code>setcol</code> will add it:</p><pre><code class="language-julia-repl">julia&gt; t = table([1,2], [2,3], names = [:a,:b])
Table with 2 rows, 2 columns:
a  b
────
1  2
2  3

julia&gt; setcol(t, :c, [1,2])
Table with 2 rows, 3 columns:
a  b  c
───────
1  2  1
2  3  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L976-L1055">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.pushcol" href="#IndexedTables.pushcol"><code>IndexedTables.pushcol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>pushcol(t, name, x)</code></p><p>Push a column <code>x</code> to the end of the table. <code>name</code> is the name for the new column. Returns a new table.</p><p><code>pushcol(t, map::Pair...)</code></p><p>Push many columns at a time.</p><p><strong>Example:</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; pushcol(t, :z, [1//2, 3//4])
Table with 2 rows, 4 columns:
t     x  y  z
────────────────
0.01  2  3  1//2
0.05  1  4  3//4
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1058-L1085">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.popcol" href="#IndexedTables.popcol"><code>IndexedTables.popcol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>popcol(t, col)</code></p><p>Remove the column <code>col</code> from the table. Returns a new table.</p><p><code>popcol(t, cols...)</code></p><p>Remove many columns at a time.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; popcol(t, :x)
Table with 2 rows, 2 columns:
t     y
───────
0.01  3
0.05  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1088-L1112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcol" href="#IndexedTables.insertcol"><code>IndexedTables.insertcol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>insertcol(t, position::Integer, name, x)</code></p><p>Insert a column <code>x</code> named <code>name</code> at <code>position</code>. Returns a new table.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; insertcol(t, 2, :w, [0,1])
Table with 2 rows, 4 columns:
t     w  x  y
─────────────
0.01  0  2  3
0.05  1  1  4
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1115-L1136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolafter" href="#IndexedTables.insertcolafter"><code>IndexedTables.insertcolafter</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>insertcolafter(t, after, name, col)</code></p><p>Insert a column <code>col</code> named <code>name</code> after <code>after</code>. Returns a new table.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; insertcolafter(t, :t, :w, [0,1])
Table with 2 rows, 4 columns:
t     w  x  y
─────────────
0.01  0  2  3
0.05  1  1  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1139-L1159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.insertcolbefore" href="#IndexedTables.insertcolbefore"><code>IndexedTables.insertcolbefore</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>insertcolbefore(t, before, name, col)</code></p><p>Insert a column <code>col</code> named <code>name</code> before <code>before</code>. Returns a new table.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [3,4], names=[:t, :x, :y], pkey=:t)
Table with 2 rows, 3 columns:
t     x  y
──────────
0.01  2  3
0.05  1  4

julia&gt; insertcolbefore(t, :x, :w, [0,1])
Table with 2 rows, 4 columns:
t     w  x  y
─────────────
0.01  0  2  3
0.05  1  1  4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1162-L1182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.renamecol" href="#IndexedTables.renamecol"><code>IndexedTables.renamecol</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>renamecol(t, col, newname)</code></p><p>Set <code>newname</code> as the new name for column <code>col</code> in <code>t</code>. Returns a new table.</p><p><code>renamecol(t, map::Pair...)</code></p><p>Rename many columns at a time.</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], names=[:t, :x])
Table with 2 rows, 2 columns:
t     x
───────
0.01  2
0.05  1

julia&gt; renamecol(t, :t, :time)
Table with 2 rows, 2 columns:
time  x
───────
0.01  2
0.05  1</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L1185-L1209">source</a></section><h2><a class="nav-anchor" id="Column-special-selection-1" href="#Column-special-selection-1">Column special selection</a></h2><p>This section describes some special types that can be used to simplify column selection. These types can be used in combination with <code>select</code>, <code>rows</code> or <code>columns</code>, as well as any other function that requires a <code>by</code> or <code>select</code> argument.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.All" href="#IndexedTables.All"><code>IndexedTables.All</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>All(cols)</code></p><p>Select the union of the selections in <code>cols</code>. If <code>cols == ()</code>, select all columns.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], [0, 0, 0, 0],
                        names=[:a,:b,:c,:d])
Table with 4 rows, 4 columns:
a  b  c  d
──────────
1  1  1  0
1  2  2  0
2  1  3  0
2  2  4  0

julia&gt; select(t, All(:a, (:b, :c)))
Table with 4 rows, 3 columns:
a  b  c
───────
1  1  1
1  2  2
2  1  3
2  2  4

julia&gt; select(t, All())
Table with 4 rows, 4 columns:
a  b  c  d
──────────
1  1  1  0
1  2  2  0
2  1  3  0
2  2  4  0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L494-L530">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Not" href="#IndexedTables.Not"><code>IndexedTables.Not</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Not(cols)</code></p><p>Select the complementary of the selection in <code>cols</code>. <code>Not</code> can accept several arguments, in which case it returns the complementary of the union of the selections.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,1,2,2], [1,2,1,2], [1,2,3,4],
                        names=[:a,:b,:c], pkey = (:a, :b))
Table with 4 rows, 3 columns:
a  b  c
───────
1  1  1
1  2  2
2  1  3
2  2  4

julia&gt; select(t, Keys())
Table with 4 rows, 2 columns:
b  c
────
1  1
2  2
1  3
2  4

julia&gt; select(t, Not(:a, (:a, :b)))
Table with 4 rows, 1 columns:
c
─
1
2
3
4</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L537-L574">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Keys" href="#IndexedTables.Keys"><code>IndexedTables.Keys</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Keys()</code></p><p>Select the primary keys.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,1,2,2], [1,2,1,2], [1,2,3,4],
                               names=[:a,:b,:c], pkey = (:a, :b))
Table with 4 rows, 3 columns:
a  b  c
───────
1  1  1
1  2  2
2  1  3
2  2  4

julia&gt; select(t, Keys())
Table with 4 rows, 2 columns:
a  b
────
1  1
1  2
2  1
2  2</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L581-L608">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IndexedTables.Between" href="#IndexedTables.Between"><code>IndexedTables.Between</code></a> — <span class="docstring-category">Type</span>.</div><div><p><code>Between(first, last)</code></p><p>Select the columns between <code>first</code> and <code>last</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; t = table([1,1,2,2], [1,2,1,2], [1,2,3,4], [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;],
                                      names=[:a,:b,:c, :d])
Table with 4 rows, 4 columns:
a  b  c  d
────────────
1  1  1  &quot;a&quot;
1  2  2  &quot;b&quot;
2  1  3  &quot;c&quot;
2  2  4  &quot;d&quot;

julia&gt; select(t, Between(:b, :d))
Table with 4 rows, 3 columns:
b  c  d
─────────
1  1  &quot;a&quot;
2  2  &quot;b&quot;
1  3  &quot;c&quot;
2  4  &quot;d&quot;</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaComputing/IndexedTables.jl/blob/3c4c3c7cc7e41cc51b17f46247fd8e8de8455454/src/columns.jl#L611-L638">source</a></section><p>Finally, to select columns whose name respects a given predicate, pass a function to <code>select</code> (or <code>rows</code>, or <code>columns</code>):</p><pre><code class="language-julia-repl">julia&gt; t = table([0.01, 0.05], [2,1], [2, 3], names=[:t, :x, :z])
Table with 2 rows, 3 columns:
t     x  z
──────────
0.01  2  2
0.05  1  3

julia&gt; select(t, i -&gt; i != :z)
Table with 2 rows, 2 columns:
t     x
───────
0.01  2
0.05  1</code></pre><footer><hr/><a class="previous" href="datastructures.html"><span class="direction">Previous</span><span class="title">Data Structures</span></a><a class="next" href="aggregation.html"><span class="direction">Next</span><span class="title">Aggregation</span></a></footer></article></body></html>
